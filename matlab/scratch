function null = specsol()
     null = 0;
     junk(2);
% boundary conditions: psi = constant (= zero) at theta = 0, pi/2.
%                      d_th omega = zero       at  "  "  "  "  " 
%                      ell, d_th_ell = 0 at    theta = 0
%                           d_th_ell = 0 at    theta = pi/2
%                       
%
%          torque-free:  psi = zero   at   r = rmin, 1
%                  d_r omega = zero    "  "  "  "  "
%                  d_r ell = - 2/r ell

clear;

% flags:
visc_f = 1;
lambda_f = 0;
circ_f = 0;
varrho_f = 0;  % radially varying density, or constant density?

iterations = 1000000;

% constants

%bc = 1; % case: bc = 0: no boundary condition specified
%       bc = 1: d(Omega)/dr = 0
%       bc = 2: d(Omega)/dr = 

omega0 = 1;  % normalize to this anyqay
nu = 1.;     % ???/
if lambda_f == 1
    V0 = 1.0;
else
    V0 = 0.0;
end

jmax = 12; % zones in r direction
imax = 20;  % zones in theta dithrection
nmax = 16; %imax; % number of functions in th-direction
xmax = 10; % number of points in cartesian directions

dt = 3.0e-6;

rmin = 0.2;  % inner edge of convection zone.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Stuff to define for the Chebyshev integral:

n = jmax-2;
xx = mycheb2(n);
w = pi*(1-xx.^2)/(n+1);  % w, W, v, are for doing integrals - see numrec
W = sqrt(1-xx.^2);
v = w./W;
%
%  Integral int_{-1}^1 f(x) dx = sum_j( v_j * f(xx_j) )  
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Grid in r-direction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Cheb2bc boundary conditions: 
%gr = [2 -1 0; 2 -rmin 0];
%[r1d_us, d2r_us, dr_us, phipr, phimr] = cheb2bc(jmax,gr);

% Cheb2bc boundary conditions: dr(Omega) = 0, without lambda effect.
% 
% vector g is: [ap bp cp; am bm cm] as defined on p.25 of Weideman & Reddy
% 
% With lambda effect,  dr(Omega) + V0 * Omega/r = 0
%
% But beware, this is a bit tricky, because cheb2bc assumes boundaries are
% at +-1, so you have to fool it!
%
% in particular, this will NOT work:
% gr = [(V0) 1 0; (V0) rmin 0];
%
% The trick is that not only do you have to rescale the spatial grid & the derivative
% matrices, but you also have to rescale the boundary conditions.

rmult = 0.5 * (1.0 - rmin);
gr = [(V0)*rmult 1 0; (V0)*rmult rmin 0];
  pause;
[r1d_us, d2r_us, dr_us, phipr, phimr] = cheb2bc(jmax,gr);

%[r1d_us, dnr_us] = chebdif(jmax,2);  % bc appropriate for ell?
%dr_us = dnr_us(:,:,1);
%d2r_us = dnr_us(:,:,1);


r1d = rmin + rmult * (r1d_us + 1.0);
dr = dr_us ./ rmult;
d2r = d2r_us ./ rmult^2;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

sr = ones(nmax,1) * r1d';
srinv = 1./sr;

% Grid in theta-direction

% Theta grid should be done using Gauss-Legendre etc, but this is not too important
% if the algorithm just transforms once each way at the beginning and end of the
% entire run......

th1d = linspace(0,pi,imax);

[r,th] = meshgrid(r1d,th1d);

[y,x] = pol2cart(th,r);   % this is done "backwards" because it's really
                          % spherical, not cylindrical....
x1d = linspace(0,1,xmax);
y1d = linspace(-1,1,2*xmax);
[xi,yi] = meshgrid(x1d,y1d);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

s = sin(th.*1.0);
s1d = sin(th1d .* 1.0);
c = cos(th);
c1d = cos(th1d .* 1.0);
sinv = [zeros(1,jmax); 1./s(2:imax-1,:); zeros(1,jmax)]; % sinv is infinite at th = 0, pi, but set to zero there.
sinv1d = [0, 1./s1d(2:imax-1), 0];
% If I can design this code well, I won't have to use sinv.
rinv = 1./r;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Initialize arrays of Omega and Psi
%
% There are two ways to do this. One is to specify them initially in the semi-spectral
% (spatial in r, associated Legendre functions in theta) domain. The other is to
% specify them in the spatial domain initially, and then project onto the
% semi-spectral domain.

% Uncomment the next three lines if you want to check for yourself that you
% are taking the right derivatives etc.:
%s = sin(th);
%dths = dth * s;
%drs = (dr * s')';

%omega = r .^ 2 .* c; % initialize with some nontrivial, uh, r- and th- dependence.
a=rmin; b=1.0;
% 3rd-order poly that has zero derivative at rmin and 1.0.
r_omega = 100 * (2*r.^3 - 3*(a+b)*r.^2 + 6 * a * b * r - 1.4);    
%r_omega = r * 0 + 1;

% now fix radial dependence of omega so that boundary conditions are satisfied
% even if lambda term is included:
fi =  (0.5) * (r - a).^2 / (b - a);  % has derivative 1 at r_max, zero derivative at rmin, also equal to zero ar rmin.
fo = -(0.5) * (r - b).^2 / (b - a);  % has derivative 1 at rmin, zero at rmax, also equal to zero at rmax.
%r_omega = r_omega - (V0 * r_omega(1,1) / b) * fo - (V0 * r_omega(1,jmax) / a) * fi;
alpha = - (r_omega(1,1)/b) / (1 + (0.5*(b-a)/b));
beta  = - (r_omega(1,jmax)/a) / (1 - (0.5 * (b-a)/a));
r_omega = r_omega + alpha * fi + beta * fo;

omega = r_omega .* (c + s);
omega = omega * (-1);
%ell = omega .* r.^2 .* s.^2;
%ellibc = ell(:,imax);

mesh(x,y,(dr * omega')' + V0 * omega./r);

%mesh(x,y,omega);
pause;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Density:

rho1d = ones(jmax,1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Project initial conditions onto associated Legendre funcions

omega_start = omega;

% Note that if g(th) = sum( g_n * P_n^1(cos(th)) / sin(th)
% thenn
% g_n = (2n+1)/(2n * (n+1)) * int_0^pi g(th) P_n^1(cos(th)) * sin^2(th) d(th)

% Integral best done using Gauss-Legendre, but here is a cheap way:

nn = 1:nmax;
norm = (2 * nn + 1) ./ ((2*nn).*(nn+1)); % normalization for P_n^1.
ed3_vec = (nn-1) .* (nn+2);  % e-value of operator (1/s^3) * d_th( s^3 * d_th( P_n^1/s )))
ed3 = ed3_vec' * ones(1,jmax);

for n= 1:nmax,
   leg_nm = legendre(n,c1d);
   leg_n1(n,:) = leg_nm(2,:);
end
for n=1:nmax, 
   for i=2:imax-1,
      leg_n1_si(n,i) = leg_n1(n,i) * sinv1d(i); 
   end
   leg_n1_si(n,1) = -n * (n+1) / 2;
   leg_n1_si(n,imax) = (-1)^n * n * (n+1)/2;
end
somega = zeros(nmax,jmax);
dth = pi/(imax-1);
for n=1:nmax,
%   for j=1:jmax,  % loop over r
%   Note that P_1^1(cos th) / sin( th) = -1, so this takes care of constant.
      somega(n,:) = norm(n) * (leg_n1(n,:) .* s1d.^2) * omega  * dth;
%      somega(n,j) = norm(n) * (leg_n1(n,:) .* s1d.^2) * omega(:,j);
%   end			   
end

%somega
%pause;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% main loop:
mod = 0;   % "mod" for "modulo": ie, a way to plot only, say, every 100th iteration.
step = 0;
while step < iterations
    step = step+ 1;

    % forward transform:
    for j=1:jmax,
        omega(:,j) = leg_n1_si' * somega(:,j);
    end

    % plotting in cartesian also    
%    omegacart = griddata(x,y,omega,xi,yi,'cubic');
%    mesh(xi,yi,omegacart);
%    pause(1.0);

    if mod==0
        mod = 100;
        mesh(x,y,omega);
        pause(0.01);
    end
    mod = mod-1;

    dr_somega = (dr * somega')';			 
    %term_a = srinv.^4 .* (dr *  (sr.^4 .* dr_somega)')';
    visc_a = nu * ((d2r * somega')'  + 4 * srinv .* dr_somega); 
			 % term_a = 0;
%			 mesh(somega); pause;
%			 mesh(term_a); pause;
    visc_b = nu * (-srinv.^2 .* (ed3 .* somega));
   
    lamb_a = nu * (dr * ( (somega .* srinv) * V0)')'   +   4 * nu * (srinv.^2 .* somega) * V0;


    somega = somega + dt *  ( visc_a + visc_b  + lamb_a);

    % checking conservation of angular momentum:

    %L1 = rho .* x.^3 .* 
    om1 = somega(1,:)';   % omega_1 - ie in spectral space - as a function of r.
    om3 = somega(3,:)';
    f1 =  (rho1d .* r1d.^3 .* om1);
    f2 =  (rho1d .* r1d.^3 .* om3);
    int1 = 2*pi * (-16/15) * sum( v .* f1(2:jmax-1));
    int2 = 2*pi * (16/35) * sum(v .* f2(2:jmax-1));
    if step == 1 
        Ltot = int1 + int2;
    end
    Ltotnew = int1 + int2;
    Lhist(step) = Ltotnew;
    %ratio = Ltot / Ltotnew
    %somega = somega * (Ltot / Ltotnew);

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% subfunctions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function crap = junk(stuff)
    crap = -1;
    
